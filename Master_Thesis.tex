%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% KTHEEtitlepage_ex.tex
%
% Example of how to use the KTHEEtitlepage package.
% 
% Mats Bengtsson,  7/8 2006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[12pt,a4paper]{article}
\usepackage[a4paper,left=3cm,right=3cm]{geometry}
\usepackage{filecontents,lipsum}
\usepackage[noadjust]{cite}
\usepackage{graphicx,wrapfig,lipsum}
\usepackage{wrapfig}
\usepackage[nonumberlist,acronym,shortcuts]{glossaries}
\graphicspath{{Images/}}
\usepackage{booktabs}



\usepackage{textcomp,xspace}
\newcommand\la{\textlangle\xspace}
\newcommand\ra{\textrangle\xspace}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\usepackage[titletoc]{appendix}
%\usepackage{appendix}
\usepackage{listings,lstautogobble}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
%\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
%\lstset{escapeinside={<@}{@>}}


\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    aboveskip=3mm,
    belowskip=3mm,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    escapeinside={<@}{@>},
    language=C,
    autogobble=true
}



\lstset{frame=tb,
    language=C,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    %basicstyle={\small\ttfamily},
    basicstyle=\footnotesize,
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    backgroundcolor=\color{backcolour}
    breaklines=true,
    breakatwhitespace=true,
    tabsize=3,
    escapeinside={<@}{@>},
    autogobble=true,
    numbers=left,
    stepnumber=5,    
    firstnumber=1,
    numberfirstline=true
}

\lstset{style=mystyle}


\usepackage[exjobb]{KTHEEtitlepage}
%\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

% Packages used in the main document for this particular example:
\usepackage{url}
\usepackage{tocloft}
\renewcommand\listfigurename{List of Figures}
\renewcommand\listtablename{List of Tables}



\newcommand{\quotes}[1]{``#1''}
\usepackage{hyperref}
\usepackage[all]{hypcap}
%\usepackage{acro}
\hypersetup{%
	pdfborder = {0 0 0}
}
\usepackage[exjobb]{KTHEEtitlepage}

 \newacronym{asip}{ASIP}{Application Specific Instruction-set Processors}
 \newacronym{ebnf}{EBNF}{Extended Backus Naur Form}
 \newacronym{cpri}{CPRI}{Common Public Radio Interface}
 \newacronym{osi}{OSI}{Open Systems Interconnect model}
 \newacronym{gpp}{GPP}{General Purpose Processor}
 \newacronym{asic}{ASIC}{Application Specific Integrated Circuit}
 \newacronym{tlm}{TLM}{Transaction Level Modeling}
 \newacronym{pla}{PLA}{Programmable Logic Array}
 \newacronym{fpga}{FPGA}{Field Programmable Gate Arrays}
 \newacronym{rbs}{RBS}{Radio Base Station}
 \newacronym{ieee}{IEEE}{Institute of Electrical and Electronics Engineers}
 \newacronym{eda}{EDA}{Electronic Design Automation}
 \newacronym{hdls}{HDLs}{Hardware Description Languages}
 \newacronym{hls}{HLS}{High Level Synthesis}
 \newacronym{rtl}{RTL}{Register Transfer Level}
  \newacronym{crc}{CRC}{Cyclic Redundancy Check}
 \newacronym{fcs}{FCS}{ Frame Check Sequence}
 \newacronym{sfd}{SFD}{Start of Frame Delimiter}
\newacronym{bnf}{BNF}{Backus Naur Form}
\newacronym{uvm}{UVM}{Universal Verification Methodology}



\makeglossaries

\begin{document}
% Information to appear on the title page:
\ititle{\textbf{Reconfigurable hardware programming  \\ in a   protocol processor unit}\\}
\isubtitle{Grammar based language framework \\ for hardware/software co-design}
%\isubtitle{}
\iauthor{ - Sunil Kallur Ramegowda}
\idate{2015}

%\irefnr{IR-EE-Dummy 2000:099}

\iaddress{ICT Labs\\
	Major in Embedded Platforms\\
		Kungliga Tekniska Högskolan}
		\makeititle

		% Everything below is exactly as for a normal document and 
		% the layout of that document should not be affected in any
		% way by the title page.
        
         \section*{Acknowledgement}
         \thispagestyle{empty}
         
         
         
         First of all i would like to thank MR. Pierre Rohdin G for selecting and providing me an opportunity to pursue Master thesis at Ericsson AB. I wish to extend my sincere thanks to Mr. Tume Wihamre and Dr. Johny oberg for supporting me to accomplish
         
         
        
         \clearpage

		\title{Reconfigurable hardware programming in a protocol processor unit}
		\author{Sunil Kallur Ramegowda}

		\maketitle
		\pagenumbering{roman}
        
       
        
       
  		\begin{abstract}
          
        %\normalsize
        \vspace*{3\baselineskip}
		%\vspace*{1in}
        Reconfigurable hardware architectures have been the topic of research for many years. Programming such architectures requires manual coding or the design of custom compilers to generate the required files for the architecture.\\
        
        A protocol processor,in general processes the packets according to the protocol. There are number of protocols like Ethernet,\acs{cpri} to define how the data has to be sent and received between the source and destination points. Data packets can be processed using a generic processors programmed in software,but hardware processing is always faster and energy efficient.\\  
        
        A compiler/mapper is investigated in this thesis work. The language application is developed using a parser generator tool called Antlr. The grammar is written in \gls{ebnf} and the corresponding language is used to describe the architecture and the protocols. The tool will generate the hardware model and their interconnection in SystemC based on the protocol description.\\ 
        
        The complete system is verified by integrating the Ethernet protocol. Parts of the protocol implementation in SystemC is also considered in the work. The system is verified for different protocols. The framework works based on the user defined description of the protocol. \\
        
        Future work involves the integration of further protocols into the system and then adapt the language to further involve all the future requirements. The concept of mapping can be used to design the hardware blocks and their interconnections in different languages. 
        
        
		\end{abstract}
        \phantomsection
        
		\addcontentsline{toc}{section}{Abstract}
       	\cleardoublepage

        %\renewcommand\contentsname{\centerline{\underline{\underline{Table of Contents}}}}
		\phantomsection
        %\cleardoublepage
        %\addtocontents{toc}{~\hfill\textbf{Page}\par}
        \tableofcontents
        %\cleardoublepage
		\addcontentsline{toc}{section}{\contentsname}
		\cleardoublepage
        
        % abbreviations
        \phantomsection
        \addcontentsline{toc}{section}{Abbreviations}
        \printglossary[type=\acronymtype,title=Abbreviations]
        \cleardoublepage

		\phantomsection
		\listoffigures
		\addcontentsline{toc}{section}{List of Figures}
		\cleardoublepage

		\phantomsection
        \listoftables
		\addcontentsline{toc}{section}{List of Tables}
		\cleardoublepage
        
        \phantomsection
        \lstlistoflistings
        \addcontentsline{toc}{section}{Listings}
        \cleardoublepage

		\pagenumbering{arabic}
         
       \section{Introduction}

		A set of rules define the communication strategy between digital systems. There are many rules which makes the communication possible between systems. Over the decades the rules have evolved into standards. \gls{osi} is an international effort to facilitate communications among different manufacture and technology. OSI reference model partition the communication system into 7 abstraction layers. It address the interconnection requirement of an open systems environment.
        
 %       \begin{figure}[!htb]
 %           \centering
 %           \includegraphics[scale=0.45]{osi}
 %           \caption{OSI Model}
 %           \label{fig:osi}
 %       \end{figure}
        
        
      % Please add the following required packages to your document preamble:
      % \usepackage{booktabs}
      \begin{table}[!htb]
          \centering
          \begin{tabular}{@{}cllc@{}}
              \toprule
              \multicolumn{2}{c}{{\bf Layers}} & \multicolumn{1}{c}{{\bf Functions}}                                                                                 & {\bf Examples}  \\ \midrule
              7         & Application          & High level APIs                                                                                                     & Mail,IE,Firefox \\ \midrule
              6         & Presentation         & \begin{tabular}[c]{@{}l@{}}Character code translation,\\ Data conversion,\\ Data compression etc\end{tabular}       & ASCII,JPEG      \\ \midrule
              5         & Session              & \begin{tabular}[c]{@{}l@{}}Session establishment between \\ processes running on different \\ systems.\end{tabular} & HTTP,SMTP       \\ \midrule
              4         & Transport            & \begin{tabular}[c]{@{}l@{}}Acknowledgement,\\ Segmentation,\\ Multiplexing etc\end{tabular}                         & TCP,UDP         \\ \midrule
              3         & Network              & \begin{tabular}[c]{@{}l@{}}Addressing,Routing,\\ Traffic control etc\end{tabular}                                   & IPv4,IPv6       \\ \midrule
              2         & Data Link            & \begin{tabular}[c]{@{}l@{}}Error free data transfer from \\ one node to another\end{tabular}                        & PPP,IEEE 802.2  \\ \midrule
              1         & Physical             & \begin{tabular}[c]{@{}l@{}}Transmission and reception in\\ physical medium.\end{tabular}                            & DSL             \\ \bottomrule
            \end{tabular}
            \caption{OSI Model}
            \label{osi}
        \end{table}
        
       
        The rules are called as protocols in communication systems. The software and/or hardware changes based on the protocol chosen to process the message and extract the relevant information at each layer of abstraction. The hardware solutions based on a \gls{gpp}  or an \gls{asic} exists \cite{5335678}\cite{558379}. GPP will have more flexibility but are less energy efficient when compared to \acs{asic} which are less flexible and most energy efficient. \acs{asip} or domain specific processors are more suitable for the protocol processing task and depending on their architectural characteristics they allow varying degrees of trade-off between flexibility and energy-efficiency\cite{1106752}. Resource and performance varies depending on the reconfigurable architecture and its level of abstraction\cite{6868627}.\\   

		The design of reconfigurable hardware architecture requires the compiler to produce the configuration or the hardware compatible code\cite{5681536}. These files can be produced on run time when the application is running or in a static way before execution. The complexity of the system depends on the selected design. The hardware for processing the different protocols can be made reconfigurable. Investigation and design of such a concept is performed in this thesis work.\\ 

		The reconfigurable hardware is modeled in SystemC language using \acs{tlm}. The files required for the reconfiguration is obtained by parsing the description of protocols using the language defined by the grammar. Antlr tool is used for building the base parser file for the defined grammar and then the required functions are implemented to output the complete system and configuration files. 
        

		
		\subsection{Background}
		In 1960 Gerald Estrin, proposed the idea of a fixed plus variable structure computer \cite{1114865}. It consisted of a fixed processor and an array of reconfigurable hardware which was controlled by the fixed processor. Even though the idea was demonstrated with a proof,the industry did not consider to further innovate in these field and till 1980's there were no significant developments. In  1985,the reconfigurable \gls{pla} was patented\cite{page1985re}. Innovation in \acs{pla}'s further continued with the commercially available \gls{fpga} in today's market.\\
        
        \acs{fpga} introduction led to the research of optimizing and reusing the reconfigurable logic blocks. The  \gls{eda} tools compile and synthesize \gls{hdls}  to create a physical design in terms of the \acs{fpga}'s resources. There were many academic and industry projects showing the concept of \gls{hls}\cite{4291932} \cite{5469564}. They operate on internal models known as control/data flow graphs (CDFG) and produces a \gls{rtl} model of the hardware implementation\cite{998629}.Increasing design complexity also created the necessity for the innovation of new \gls{eda} tools.\\ 
                  

		Ericsson AB \cite{ericsson} is a market leader in the radio base station equipments. There are different protocols being used for communication in the Radio Base Station (RBS) units. Ethernet explained by \acs{ieee} in 802.3 standard defines the protocol for 10Gbit transfer which is mainly used for communication between the silicon chips. Other protocols include \gls{cpri},Serial Rapid IO(SRIO),Xio-s(Ericsson Specific protocol) for reliable communication between chips at high data rate. Most of these protocols in MAC layer of abstraction share common functions. Ericsson design and manufacture custom \acs{asic} chips for these protocols. The common functions which can be used by different protocols for designing a reconfigurable architecture which will minimize the hardware cost and will provide more flexibility compared to ASIC chips. More details about the protocols and reconfigurable architecture is explained in Chapter 3.\\ 

		The reconfigurable architecture requires a new hardware and software co-design. The reconfiguration details are extracted based on the hardware design and the compiler/mapper should be able to produce such reconfiguration. This is accomplished  by using Grammar based technique i.e by defining a language based on \gls{ebnf} grammar and then describing the protocols using this language. The overall architecture and working principle will be explained in further chapters.\\

		The thesis deals with understanding the reconfigurable architecture and identifying the configuration details to make the system work for different protocols. The description in high level language is used to extract these configuration details and to verify the complete system using a test bench.\\   

	


		\subsection{Purpose}

		The thesis purpose is to investigate an approach of a compiler or mapper to describe the protocols in high level language and then map it to hardware blocks and their interconnection. This involves showing the proof of concept by SystemC TLM simulation models. The Individual hardware blocks are modeled in SystemC and can vary from a simple block to complex functions of the protocols. This thesis work serves as a proof for the project in Ericsson AB to further investigate the feasibility of developing such architectures.


        \subsection{Problem Description}
            As explained in the previous section reconfigurable architecture with lowest granularity are available for different applications.They still face the challenges of lower speed,high energy consumption and the compatibility of tool chains between different vendors. The lowest reconfigurable granularity can be designed at bit,block or function level. When targeting hybrid architectures to improve either performance,cost or speed, the application must be partitioned in such a way that certain repetitive or computation intensive functions are mapped on a reconfigurable hardware. Such mapping is not simple as it requires deep understanding of both hardware and software design \cite{1395538}. 
            
            Reference for below figure \cite{book}
            
             \begin{figure}[!htb]
                            \centering
                           \includegraphics[scale=0.45]{designgap}
                            \caption{Hardware Software Design Gaps versus Time.}
                            \label{fig:designgap}
             \end{figure}
            
            
            
            The know how of this process to build the complete system which solves the practical problems are of great importance. The MAC layer shares the common functions among different protocols. How the reconfigurable hardware can be programmed to accomplish the protocol processing in an efficient way by designing the framework using high level description needs to be explored. This allows the user with minimal know how about hardware to reconfigure and show result in short time.

		\subsection{Goals}
		The thesis goal is to achieve the below milestones:
        
        \begin{itemize}
            \item{Understand the reconfigurable hardware architecture designed at Ericsson AB}
            \item{Understand Ethernet,Xio-s and CPRI protocols}
            \item{Define a language to describe the protocols in high level description}
            \item{Identifying how to represent the reconfiguration information}
            \item{Mapping the description of language to hardware and interconnections}
            \item{Integrating Ethernet protocol for the complete system}
            \item{Verifying the system by simulation}
            
            
        \end{itemize}
        
      	               

		\subsection{Limits on scope}
		The thesis focus more on showing the proof of concept considering one to two protocols i.e Ethernet and Xio-s. The language will be designed such that it is easy with minor modification to extend for other protocols like CPRI. Developing and integrating the \acs{tlm} models for all the protocol's will not be feasible in this time line. The architectural changes required are suggested but not changed as the focus is more on describing the protocol in high level description.

		\subsection{Structure of the thesis}
		The thesis is organized to provide required details for understanding the overall work. The first chapter gives a brief introduction to the reader about the topic of investigation,limitations and goals.The rest of the thesis is structured as follows.\\
        
        
        \textbf{chapter 2}  This chapter  will describe the background about the topic. It is summarized in three sections starting with Reconfigurable hardware architectures and their terminologies,different protocols and their functions and grammar introduction. It also introduces the simulation environment and languages used to model the hardware.
        \newline
        
       \textbf{chapter 3}  This chapter describes the research methodology inculcated in carrying out this thesis work. It starts with the research process and then the introduction of the reconfigurable hardware architecture under study i.e Freyja architecture details.  Then the process of building a language application is explained using Antlr tool. The comparison of three protocols under study and their common functions are also discussed.\\
        
        \textbf{chapter 4}  The chapter starts with the details of building the framework. It also discuss how the architectural requirements are mapped using the high level description. Mapping of Freyja operators,their memory contents,interconnections and error handling are discussed.\\
        
        \textbf{chapter 5}  This chapter explains the details of complete test system. How the overall system can be represented using the input file and how the data is processed and handled within the system.\\
        
        \textbf{chapter 6}  This chapter explains the integration of Ethernet protocol functions into the  system of files auto generated from the language application. The challenges and the mapping of input description are discussed in detail. The Xio-s protocol is also considered but part of the functions are integrated to show the context switching and highlighting the control block changes.\\
        
        \textbf{chapter 7}  This chapter explains the conclusion and future work.\\
        
        
        
          
		\clearpage


		\section{Background}
		To understand the reconfigurable hardware and its terminologies, this chapter explains in detail about the architecture and its meaning. Protocols and their common functions are also explained which helps in designing the reconfigurable protocol processors. The further sections explains the meaning of grammar and language and its terms.    


		\subsection{Reconfigurable Systems} \label{reconf}


		In the field of computer architecture, designers make decisions based on flexibility and performance requirement\cite{JACST518}. \acs{asic} are the least flexible in terms of adapting for any change in the application and GPP are the most flexible as they are independent of the application and the core can be programmed to make the required algorithm work at the cost of higher power and lower efficiency. ASIC and GPP lies in extreme corners of the graph between Flexibility Vs Performance as in Fig.~\ref{fig:Fig1}. Reconfigurable architectures are intended to fill the gap and provide more flexibility in terms of hardware and potentially higher performance than software\cite{JACST518}.

		\begin{figure}[!htb]
		\centering
		\includegraphics[scale=0.45]{Fig1}
		\caption{Flexibility Vs Performance of Hardware Classes}
		\label{fig:Fig1}
		\end{figure}

		\subsubsection{Granularity} 

		Reconfigurable devices like \acs{fpga} have the configurable logic blocks(CLB) which can be configured to map the required functionality. The complexity of the function is not a concern but the number of inputs and output of the function has to be considered based on the FPGA architecture. This level of granularity in implementing the functions is called as Fine grained Reconfigurable architecture as it provides the reconfigurable granularity till lowest possible level. These reconfigurable devices are not energy efficient and the execution speed is too less than the ASIC counterpart. Another type of reconfigurable devices are the coarse grained reconfigurable architectures. These devices have the granularity at function levels. They will configure the function blocks to achieve the efficient algorithm implementation.The function blocks can vary from constant block to complex functions which are commonly used based by the application.   


		\subsubsection{Reconfiguration Models}
		The reconfigurable architectures need configuration of hardware. This can be at compile time or at runtime of an application as in  Fig.~\ref{fig:Fig2}.

		\begin{figure}[!htb]
		\centering
		\includegraphics[scale=0.45]{Fig2}
		\caption{Reconfiguration Models}
		\label{fig:Fig2}
		\end{figure}

		In compile time reconfiguration model, the reconfigurable hardware system is configured at compile time and will be static during the application run time. In this model the programmable logic can be configured to perform some specific task like hardware accelerators to achieve high performance. FPGA configured to perform floating point multiplication together with a GPP will accelerate the performance of the application if the GPP doesn't have a Floating Point Unit.
		In run time reconfiguration model, the reconfiguration hardware is configured at run time and will be dynamically programmed to perform different tasks. The decision for making such dynamic reconfiguration has to be embedded coupled with the application and hence it increase the overhead. The Dynamic Reprogrammable Resource Array(DRRA) fabric developed at KTH Electronic System Dept is an example of this model\cite{5351593}.   

		\subsubsection{Reconfiguration rate}
		The Fine grain Systems will have more reconfiguration data(In FPGAs it is in term of bit streams) which leads to more time and the Coarse Grained Reconfigurable systems will have comparatively less blocks as they have higher granularity and will contain less reconfiguration data. Hence the Coarse Grain architecture will take less time to re configure. This depends on the dynamic reconfiguration architecture whether the complete fabric is reconfigured or partially reconfigured during runtime. 


		\subsection{Protocols}\label{protocols}

		The communication between chips in Radio Base station equipments has many protocols to fulfill the requirements of the specification. The protocols differ by standards. The different protocols being used at Ericsson AB and related to this thesis work are described below:  

		\subsubsection{Ethernet}
		Ethernet  is a widely used protocol for data communication. It is typically used in Local Area Network (LAN) applications. IEEE organization has standardized the protocol and revises it according to the technological advancement. The recent standard available is from 2012 \cite{iethernet} and it defines the protocol for different applications.
        
        \subsubsection*{Ethernet Transmit}
            The Ethernet transmit sequence is shown in Fig.~\ref{fig:EthTx}.
        
       \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.45]{EthTx}
            \caption{Ethernet Transmit}
            \label{fig:EthTx}
       \end{figure}
       
       The \textit{DataIn} is from the higher layers of the protocols which contains the data to be transmitted using MAC layer protocol. Physical layer protocols are out of this thesis scope and not explained.
       
        
       \subsubsection*{Ethernet Receive}
           The Ethernet receive sequence is shown in Fig.~\ref{fig:EthRx}. \textit{DataIn } is from the physical transmission layer and \textit{Dataout} is to the higher protocol layers.
       
            \begin{figure}[!htb]
             \centering
             \includegraphics[scale=0.45]{EthRx}
             \caption{Ethernet Receive}
             \label{fig:EthRx}
            \end{figure}
            
       \subsubsection*{Ethernet Raw frame}
       
       The Ethernet raw frame format is represented as in Table.~\ref{ethframe}. Each of these frames enter the transmitter \textit{Datain} as in  Fig.~\ref{fig:EthTx} and in the receiver \textit{ Dataout} as shown in Fig.~\ref{fig:EthRx}. 
       
       \begin{table}[!htb]
           \centering
           
           \begin{tabular}{|c|c|c|c|c|}
               \hline
               {\bf \begin{tabular}[c]{@{}c@{}}Mac Destination\\ Address\end{tabular}} & {\bf \begin{tabular}[c]{@{}c@{}}Mac Source \\ Address\end{tabular}} & {\bf \begin{tabular}[c]{@{}c@{}}802.1Q\\ VLAN tag\end{tabular}} & {\bf Ethertype/length} & {\bf Payload} \\ \hline
               6 octets                                                                & 6 octets                                                            & 4 octets                                                        & 2 octets               & 42-1500 octet \\ \hline
            \end{tabular}
            \caption{Ethernet raw frame}
            \label{ethframe}
        \end{table}
       
       A brief functional description of each blocks in the transmitter and receiver section is explained below.
       
       \subsubsection*{CRC}
        \gls{crc} is used to detect errors incurred during the physical transmission. The \gls{crc} value is computed by dividing the data to be transmitted with the pre-defined CRC polynomial stored in the memory\cite{4066263}. The remainder of the division is known as the \gls{fcs}.\\ 
        
        In transmitter side the \gls{fcs} is computed for the incoming data and appended as last 4 bytes (32bits). In the Ethernet receive, the \gls{fcs} is again computed for the incoming data and is compared with the FCS field for any errors.  This block will not change the incoming data apart from appending the \gls{fcs} field.
        
        \subsubsection*{Preamble and SFD}
        Preamble is added at the start of the frame to indicate the new Ethernet frame. This block will not change the incoming data apart from adding the Preamble(7bytes) and \gls{sfd} at the beginning of the frame(1byte).\\ \\
        
        \begin{table}[!htb]
            \centering
            
            \begin{tabular}{c|l}
                \hline
                Preamble & 10101010 10101010 10101010 10101010 10101010 10101010 10101010 \\ \hline
                SFD      & 10101011                                                       \\ \hline
            \end{tabular}
            \caption{Preamble and SFD}
            \label{psfd}
        \end{table}
        
      
        In the receiver, the Preamble and SFD are identified and deleted.
        
        \subsubsection*{Control codes}
        
        The Add control codes block will add the control codes for the incoming data such that Encoder block can use the 8 octets to encode the data based on this control codes. Idles are added to the data if the length of the data is not equal to 8 octets. Each bit in the control word represents whether the octet is data, terminate or an idle octet.
        
        
        \begin{table}[!htb]
            \centering
            
            \begin{tabular}{c|c|c|c|c|c|c|c|c}
                \hline
                {\bf Type}                                                    & Idel & Idel & Terminate & Data 4 & Data 3 & Data 2 & Data 1 & Data 0 \\ \hline
                {\bf \begin{tabular}[c]{@{}c@{}}Control \\ word\end{tabular}} & 1    & 1    & 1         & 0      & 0      & 0      & 0      & 0      \\ \hline
            \end{tabular}
            \caption{Control Word}
            \label{controlword}
        \end{table}
        
        
             
        In the receiver, the complete process is reversed. It will search for the control word and delete before forwarding to the next block.
        
         \subsubsection*{Encoder 64/66B and Decoder 66B/64B}
         
          \begin{figure}[!htb]
              \centering
              \includegraphics[scale=0.35]{encoder}
              \caption{Ethernet Encoder block}
              \label{fig:encoder}
            \end{figure}
         
         The Encoder block is represented as show in Fig.~\ref{fig:encoder}. The 8 octet data is encoded using the control word into 66 bit output. The first 2 bits of the output are called sync header which is used for the synchronization from the receiver. The sync header \quotes{10} correspond to data and \quotes{01} corresponds to control codes
      
        In the decoder the sync header is used to synchronize the 66bit data. The process of decoder is the reverse interpretation of the encoder module.
        
        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.35]{decoder}
            \caption{Ethernet Decoder block}
            \label{fig:decoder}
        \end{figure}
        
        
         \subsubsection*{Scrambler and Descrambler}
            
            This block is used to randomize the signal so that long sequence of 1's and 0's are eliminated. This is performed using the Scrambler polynomial.
            
            The De-scrambler will take the scrambled input and will output the unscrambled data.  
        
         \subsubsection*{Gearbox}

           This block is used to switch output rates. The incoming data is transmitted at different rates based on the clock frequency.
           

        
        
		\subsubsection{Xio-s}\label{xio}
		Xio-s is Ericsson proprietary protocol used for communication between chips.
        
        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.45]{Xiotx}
            \caption{Xio-s Transmitter}
            \label{fig:Xiotx}
        \end{figure}
        
        
        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.45]{XioRx}
            \caption{Xio-s Receiver}
            \label{fig:XioRx}
        \end{figure}
        
      \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.45]{xiotype1}
            \caption{Xio-s Frame format Type 1}
            \label{fig:xiotype1}
        \end{figure}
        
        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.45]{xiotype2}
            \caption{Xio-s Frame format Type 2}
            \label{fig:xiotype2}
        \end{figure}
        
        There are 7 different types of packet services for Xio-s protocol. This assigns the packet to proper channel based on the service type. As an example, if the service type format 1 then it uses only CRC16 channel or if the Service type format II then it uses both CRC16 and CRC32 channels.
        
        
        \subsubsection*{CRC}
        There are 16bit and 32bit CRC calculations required in Xio-s protocol. So the polynomials for CRC16 and CRC32 are stored in the memory and the function is used according to the service type.
        
        In the receiver, the CRC is again computed and compared with the received bytes. 
        
        
        \subsubsection*{Flow control characters}
        
        The flow control character will add the control word similar to Ethernet protocol in each channel. These are used for indication of start and end of frames.
        
        In the receiver the flow and control characters are identified and deleted.
        
        
        \subsubsection*{Encoder/Decoder}
        The encoder module will encode one octet at a time to 10bits. So for 8 octects it outputs 80bits The encoder 8B/10B is invented by IBM and famous for short run length and DC balance.
        
        The decoder module does the reverse of encoder and thus the output of decoder will be the same as the input of encoder.
        
        \subsubsection*{Striper}
        It is used to split the 80bits incoming data into 40bits of 2 physical channels to increase the data transfer rate.
        
        
        \subsubsection*{Frame Sync}
        This block is used to synchronize the receiving data.It is performed using the special character in the transmitted data called as k28.5 character.
        
        
        \subsubsection*{Aligner}
        This block is used in the receiver if striper is used in the transmitter side.It aligns the two incoming 40bits channels into one 80bits channel.
        
        
		\subsubsection{CPRI}
		
        
        
         \begin{figure}[!htb]
             \centering
             \includegraphics[scale=0.45]{cpritx}
             \caption{CPRI Transmitter}
             \label{fig:cpritx}
            \end{figure}
            
         \acs{cpri} is an industry cooperation aimed at defining a publicly available specification for the key internal interface of radio base stations between Radio Equipment Control(REC) and the Radio Equipment(RE) \cite{cpri}. It is the co operating work of Ericsson AB,Huawei Technologies Co.Ltd,NEC corporation,Nortel Networks SA and Siemens AG.   
         All the blocks in this protocol are similar to the blocks in Ethernet protocol. The frame structure is similar to the Xio-s protocol.
         
            
            
        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.45]{cprirx}
            \caption{CPRI Receiver}
            \label{fig:cprirx}
        \end{figure}
        
        
        
       
        
        
        
        

	    \subsection{Grammar and Language} \label{grammar}
        
        A Grammar is used to describe the syntax of a language, that is, all possible legal sentences or combination of words that make up the language. More formally, Grammar G describes all allowed legal sequences of strings. This is called the language(G) of the grammar.
        The language in turn is made of sequence of elements which can be letters, numbers or special symbols. For example, In the word \quotes{KTH} the capital letters K,T,H are to be recognized and then the word needs to be formed. This is performed by the Lexer which recognizes the letter and forms the token.
        To be able to recognize words, Lexer need some special constructs. These special constructs makeup the language that can be recognized by regular expressions. For example, regular expression [0-9] recognizes a single letter in the range from 0 to 9. 
        
        
        \subsubsection{Parser}
            The Lexer scans the input character streams and forms the valid tokens. The Parser takes tokens as inputs and then based on the parsing rules in the grammar, decides the parsing strategy. The parser output can be used either to create an interpreter or a compiler. 
            
            
            \begin{figure}[!htb]
                \centering
                \includegraphics[scale=0.45]{parsetree}
                \caption{Parser}
                \label{fig:parsetree}
            \end{figure}
        
        
        Here, a language application is built to output the reconfigurable hardware architecture. Hence the parser output is used to translate it to the required output. 
        
        \subsubsection{Backus-Naur Form}

		In computer science world, \gls{bnf} is the notational technique for context free grammars. It is a set of derivation rules to define the language.\\ 
        
        For example,\\
           
       \la int\ra  \hspace{0.2cm} ::= \la DIGIT \ra    | \la int \ra  \la DIGIT \ra \\
       
               \la DIGIT \ra \hspace{0.2cm} ::= [ 0-9 ]\\
        
        In the above Grammar, \la int \ra on the left hand side is called as non terminal and the \la DIGIT \ra is called as terminal. So the sequences of digits like 9999... can be parsed by representing grammar as above \gls{bnf} code. 
        An extension to BNF grammar with more operators to write the syntax is called as EBNF. The grammar above can be rewritten in EBNF as below \\
        
        \la int \ra ::= \la DIGIT \ra * \\
        
        Here * means one or more occurrences of digits. Similarly \quotes{+} operator means 0 or more occurrences.
        
        

	

	
		\subsection{Environment and Tools}
         The EBNF description of the grammar is used by the Antlr4 tool to parse the input file and  produce the source and configuration files of the architecture. The hardware modeling is achieved by using SystemC and the verification by \gls{uvm}. 
        
           
        \subsubsection{SystemC}
         SystemC is an ANSI standard C++ class library for system and hardware design for use by designers and architects who need to address complex systems that are hybrid between hardware and software \cite{1617814}. It helps in modeling the concurrent processes. This makes it possible to model the hardware which are concurrent systems by nature.  
        
        \subsubsection{TLM}
         Transaction level Modeling is the approach of abstracting the lower implementation details of the function units and representing the overall system architecture. TLM helps in modeling the communication and the function unit implementation separately \cite{tlm}. The Transaction refers to the set of data being exchanged. TLM speeds up the simulation by replacing a set of pin level events with a single function call.TLM 2.0 standard is used for the implementation of the bus system.\\
         
         
         
       \subsubsection{UVM}
       Universal Verification Methodology(UVM) is a verification methodology based on the best features of OVM(Open verification Methodology) and Verification Methodology Manual(VMM) \cite{uvm}. A Base version of UVM is used to verify the functionality of the architecture.  
       
		\clearpage


       \section{Methodology}
       
      This chapter explains the process applied in describing the protocol for the hardware architecture. It also explains the details of reconfigurable architecture under study, the common protocol functions and the methodology used to verify the result. 
       
       \subsection{Research process}
            The hardware architecture and its interconnections need to be understood to design the protocol processor. The reconfigurable architecture developed at Ericsson AB is called as Freyja architecture. The hardware architecture details has to be abstracted out to define it in high level description. Similarly the protocols details has to be abstracted using the same description to reconfigure the hardware for different protocols. The mapping between them requires a custom set of files to define and reconfigure the architecture according to the requirement. To accomplish this,the research involves the following major steps:
            \begin{itemize}
                \item{Study the Reconfigurable hardware architecture}
                \item{Identify the common protocol functions}
                \item{Develop a grammar to describe the details in high level language}
                \item{Test the developed system}
               \end{itemize} 
       
       The study of the architecture is explained in detail in the next section. The further sections explains the process involved in achieving the remaining steps. 
       
       \subsection{Freyja Architecture} \label{freyja}
           As in Figure~\ref{fig:Freyja} , Freyja architecture is a reconfigurable protocol processor. It consists of different protocol operators which are connected through the central switch. This switch based network topology can be configured to process the data based on protocols. The Ring bus (RB) interface the Freyja with the higher layers of protocol and it issues the data frames of different protocols as tokens. The Common Memory Interface(CMI) is used to fetch the data from memory. 
           The physical interface is represented by the Serializer/Deserializer block i.e SERDES. The details of each of the Freyja architecture blocks are discussed below.
           
            \begin{figure}[!htb]
                \centering
                \includegraphics[scale=0.4]{Freyja}
                \caption{Freyja Architecture}
                \label{fig:Freyja}
            \end{figure}
           
       
       \subsubsection{Switch port}
       
       \begin{wrapfigure}{R}{0.4\textwidth}
           \vspace{-30pt}
           \centering
               \includegraphics[width=0.4\textwidth]{switchport}
            
            \caption{Switch port}
            \label{wrap-fig:switchport}
            
        \end{wrapfigure} 
        
       Freyja Switch port is the smallest unit in the architecture which receives the transactions from different functions and then forwards it to the internally connected next switch port based on the destination of the transaction. It consists of a simple initiator socket,simple target socket,Multipass through initiator socket and Multi pass through target socket. It is represented as in \lipsum[0-0] Figure~\ref{wrap-fig:switchport}
 
    \subsubsection{Operator units}\label{operator}
       
       
       \begin{figure}[!htb]
           \centering
           \includegraphics[scale=0.5]{operator}
           \caption{Freyja operator}
           \label{fig:operator}
        \end{figure}
       
      
       Freyja Operator units are designed to contain a control, process and memory blocks. Each operator function is implemented in the process block and the transaction routing and context switching is performed in the control block. The memory block stores the constants required for the process block. It can also be used to store the result and then the control block can access the results. 
       As in Figure~\ref{fig:operator} , the 3 components of each operator is encapsulated with one simple initiator socket and one target socket which initiates the transaction and receives the transaction from the switch respectively. The transaction received in routed to the control block where it sends the transaction to memory block about the received transaction. Based on the required operator, the memory block will send the transaction to the process block. Meanwhile the received transaction is sent to the process block from the control block to perform the required operation. 
       
       
       \subsubsection{Switch wrapper}
        The switch wrapper instantiates the switch ports and their interconnections. Based on the number of operators the required number of switch ports is instantiated.
        
        
         \begin{figure}[!htb]
             \centering
             \includegraphics[scale=0.5]{switchwrapper}
             \caption{Freyja Switch Wrapper}
             \label{fig:switchwrapper}
            \end{figure}
        
        As in Figure~\ref{fig:switchwrapper}, each switch port can send the transaction to any of the other switch port through the internal multi pass through socket. The other switch ports can receive the transaction using the multi pass through receive socket. A transaction source and destination cannot be the same operator as there is no such interconnection.
        
        \subsubsection{Overall architecture}
        
        Assuming there are 4 operators in the Freyja architecture, an illustration of the system is shown in Figure~\ref{fig:Overallarchitecture}
            
        
         \begin{figure}[!htb]
             \centering
             \includegraphics[scale=0.5]{Overallarchitecture}
             \caption{Freyja Architecture for 4 operators}
             \label{fig:Overallarchitecture}
            \end{figure}    
       
       The overall Frejya architecture consists of switch wrapper instantiating switch ports and the operator blocks for each of the operator functions. A transaction originating from operator 1 as shown in fig with orange box can be routed to any of the other operators as destination based on the address of the payload. This will be assigned in the control block of the operator where the transaction is originated. 
       
       \clearpage
       
       \subsection{High level description of the protocol}
          High level language description requires the design of Lexer and parser as explained in Section \ref{grammar}. They can be designed using languages like C,C++,java,C\# and more. Based on the application requirement, a parsing strategy needs to be decided. As the machine resources grew in today's world, researchers have developed more complex and powerful Non Deterministic parsing strategies. Today both \quotes{bottom-up} and \quotes{top-down} approaches exist. Debugging a \quotes{bottom-up} parsers are hard to understand and debug compared to the \quotes{top-down} parsers.\\
          
          There are many tools like ANTLR4,APG,AXE,YACC etc which helps to build a language application. They provide the user with Lexer and Parser implementations for the matched grammar defined by the user. This helps in reducing time for building the language in a short time. Antlr is one such tool which helps in designing the recursive descent top-down parser and a clear error recovery mechanism.           
       
         
         
         	\subsubsection{Antlr}
             
            ANTLR4 accepts as inputs any context-free grammar that does not contain indirect or hidden left-recursion.\cite{antlr4}. Antlr 4 generates a recursive descent top down parser. It uses ALL(*) production prediction function. ALL(*) prediction mechanism launches sub parsers at decision point and they operate in pseudo parallel to explore all possibilities of input combinations. Antlr 4 currently generates parsers in Java or c\# and the previous version supports even C and C++.\\ 
            
            
              \begin{figure}[!htb]
                  \centering
                  \includegraphics[scale=0.3]{antlr}
                  \caption{Antlr}
                  \label{fig:antlr}
                \end{figure}
            
            Antlr 4 grammar use yacc-like syntax with EBNF operators like Kleene star(*) and token literals in single quotes. Both Lexical and syntactic rules are specified in the same grammar file. The Lexical rules are specified in capital letters which distinguishes them from others.\\
            
            
            Figure~\ref{fig:antlr} illustrates ANTLRs yacc-like metalanguage. Antlr 4 automatically rewrites the rule to be non left recursive and unambiguous. The grammar analysis is performed at parse time and caching results in lookahead DFA for efficiency.\cite{antlr4}. 
             
          
             \subsubsection*{Parse tree listners and Visitors}
             Antlr provides 2 tree walking mechanisms in its runtime library. In parse tree Listners, ANTLR generates a parsetreeListner subclass specific to each grammar with entry and exit methods for each rule. This is suitable for applications wherein the complete tree need to be invoked from root till the last leaf node in-order. The parse tree Visitor mechanism is used when the tree walking needs to be controlled.
             
              
        \subsection{Comparison of 3 Protocols} \label{protocol}
        
        The parser generator tools need to be used to describe the protocols and produce the reconfigurable files for the hardware architecture. The protocols of the MAC layer considered in this work are explained in section \ref*{protocols}. 
        
        The common functions in each protocol are highlighted with the same color for the boundary line in Figure~\ref{fig:common_tx} \& Figure~\ref{fig:common_rx}. A common hardware architecture can be designed with minimal reconfiguration to perform the protocol processing of different protocols stated above.\\
        
        
        
        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.35]{common_tx}
            \caption{Transmitter of all 3 protocols}
            \label{fig:common_tx}
        \end{figure}
        
        
        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.4]{common_rx}
            \caption{Receiver of all 3 protocols}
            \label{fig:common_rx}
        \end{figure}
        
        \clearpage
       
         \subsection{Modelling and Testing}
         
         
         
         
       \clearpage
       

		\section{Developed language}
            A language description is developed to define the Freyja architecture which maps different protocol operators and their interconnections. The high level description accounts for different operator?s instantiation, transaction routing, constants in memory and error handling. Each of these is explained in detail in this chapter.
            
        \subsection{Parser implementation}
            Antlr tool is used as a parser generator to develop the language. The grammar is defined using EBNF. Antlr parser use a new parsing technology called Adaptive LL(*). This parsing strategy combines the simplicity, efficiency and predictability of conventional top-down LL(k) parser with the power of GLR like mechanism to make parsing decision. It performs the grammar analysis dynamically at runtime rather statically. The grammar analysis is moved to parse time which helps to handle any non-left recursive context free grammar.
            
            
             \begin{figure}[!htb]
                 \centering
                 \includegraphics[scale=0.5]{antlrfiles}
                 \caption{Antlr generated Files}
                 \label{fig:antlrfiles}
                \end{figure}
        
        A brief description of the generated file are stated below:\\
        
        Freyja\_archInitparser.java: contains the parser class definition specific to grammar Freyja\_arch that recognizes our Freyja protocol processor language syntax.\\
        
        Freyja\_ArchInitLexer.java: This file contains the lexer class definition by analyzing the lexical rules in the grammar.\\
        
        Freyja\_archInit.tokens: Antlr generates a token type number to each token in the grammar and store these values in this file.\\
        
        Freyja\_ArchInitListner.java, Freyja\_archBaseListner.java: Antlr parser builds a tree walker that can trigger the callback events to a listener objects. Freyja\_archInitListner is the interface that describes the callbacks and Freyja\_ArchBaseListner is a set of empty default implementations.\\
        
        The backend functions are implemented to produce the Freyja architecture based on the language described. 
        
        
        \subsection{Operator Instantiation}
        As explained in the Figure~\ref{fig:CRC}, each of the operator in Freyja architecture consists of a control block to take of the transaction routing and error handling and a memory block for storing the constants and results and the process block to perform the operator function.
        
        
         \begin{figure}[!htb]
             \centering
             \includegraphics[scale=0.5]{CRC}
             \caption{CRC operator in Freyja Architecture}
             \label{fig:CRC}
            \end{figure}
            
            
             In a protocol processor consisting of operators for transmitting and receiving the data frames, the functions performed during the transmitting stage might need to be performed in the receiver stage. For instance, FCS is appended during the transmitting stage and in the receiver stage the computation of CRC is performed again. In addition, it performs the comparison of the received FCS value and the newly computed value to identify if the received data is erroneous or not.\\
 
            The control block of each operator has to identify the destination operator within the process block to forward the payload to exact operator. The language described has to consider this feature when instantiating the operator and defining the control blocks for each operator. An example of CRC block with CRC ADD and CRC check operators are discussed further.\\
            
            As in Figure~\ref{fig:CRC}, the CRC function to compute the CRC is used by both CRC ADD and CRC CHECK operators. The control block has to check if the destination operator is CRC add or CRC check and forwards the data to be processed to the correct operator and also should indicate the memory block to forward the required constants for the process blocks. This is further explained in the next section.\\
            
            The operator is defined as below:
            
            \begin{lstlisting}[caption={Freyja Operator Instantiation}]
            
<@\textcolor{blue}{Operator}@> CHECKSUM{
<@\textcolor{red}{sc\_name} @>: crc;
<@\textcolor{red}{op\_type} @>: crc_add,crc_check;
<@\textcolor{red}{op\_mem} @> : 0x01,0x04,0xc1,0x1d,0xb7,0x20,0x00,0x04,0x03,0x04,0x00,
           0x00,0x01,0x59,0x53,0x10,0x03,0x02,0x04;
<@\textcolor{red}{errorid} @>: 02,03;
} 
         \end{lstlisting}
        
        The operator name CHECKSUM identifies the unique operator in the Freyja architecture. The sc\_name field is used to create the systemC file with fre\_op\_ctrl\_crc,fre\_op\_proc\_crc,fre\_op\_mem\_crc files which are the control,process and memory blocks respectively. Each operator definition also takes care of including a switch port and modifying the switch wrapper functions to take care of the interconnections. 
        
        \subsection{Context switching}
        
        The context switching in the process block is performed based on the destination operator for the data packet. The interconnect information is by the control block to determine the protocol and destination operator for the data packet. The control block will then forwards the transaction to the process block where the context switching between the operators are performed. The operator type field will indicate the process block to switch between the operators.\\
        
        The control block also indicates the memory block to send the required constants for the process block. For the CRC operator, as in Figure~\ref{fig:CRC}, the control block will determine the protocol and the operator type and then informs the memory blocks with the transaction payload. The control block will send the received transaction to the process block. The memory block will decodes the operator and then sends the constants required for the operator through a transaction. The process block will do the context switching of operator between CRC add and CRC check to obtain the result according to the destination operator.\\ 
        
        Once the results are obtained, the process block will send it to the control block. The control block will forward the transaction to the next block.\\ 
        
      
        \subsection{Memory}
        
        The memory block is designed to store the constants required for the operators and also to store the results. But currently the results are not stored in memory, as only one protocol is implemented.\\
         
        The constants to be stored in the memory are indicated in the op\_mem field. Each operator is allowed store all the constants in the memory and based on the operator in use the constants can be forwarded to the process block through a transaction. As in operator checksum definition, the memory contains 19 bytes which are used by the CRC16 and CRC 32 operators.\\
         
        Memory transaction for each protocol are described in the language as below  
        
         \begin{lstlisting}[caption={Freyja Memory content definition}]
<@\textcolor{blue}{memory} @>{
<@\textcolor{red}{crc\_add} @>   :00 to 08;
<@\textcolor{red}{crc\_check} @> :00 to 07,09;
<@\textcolor{red}{scram} @>     :00 to 07: 
<@\textcolor{red}{descram} @>   :00 to 07;
} 
        \end{lstlisting}
       
        
        As in code above the first 8 bytes of contents are sent as a transaction from memory for the CRC ADD operation in CHECKSUM operator. The different forms of notation can be observed in the CRC check wherein the memory bytes can be specified with individual address. Each protocol with the memory code as above can send transaction for different operators. In the above code, the crc add,crc check,scram and descram send the transaction to their respective blocks.
        
        
        
        \subsection{Transaction handling}
        
        The transaction routing for each protocol is described in the input file using the below syntax \\
        
        CONNECT: <source operator> to <Destination operator>\\
        
        Based on these all the control blocks will be configured with the destination address for the payload. The switch interconnect will send the transaction to the next operator based on this address. This mapping defines the transaction routing for each protocols and is used to build the destination address automatically using the input description. 
        
        \subsection{Error handling}
        
        Any erroneous packets can be sent to the error handler from each of the operator. The control block will check for the process block result, if there are any errors then it informs the control block through the FBI header and the control block will send the payload to error handler for further processing and will not be sent to the destination operator.\\
        
        The error id for each operator can be implicitly assumed or even possible to mention as an explicit number. 
        
        
        
        
        
		\clearpage

		\section{Tests}
         This chapter describes the test system, testing strategy, input protocol file, discussion about output obtained.
         
         \subsection{Complete Test System}
            As in Figure~\ref{fig:testsystem}, the first switch port is connected to the UVM test bench. The UVM environment will drive the input signals according to the Freyja architecture. The Freyja interconnect consists of 4 bytes header field and the data payload as in Figure~\ref{fig:header}. 
            In SystemC implementation the first byte is considered to hold the unique protocol id and the second byte to have the unique operator id, the third byte and fourth byte are for Flow control and Context/error handling. 
            
        
          \begin{figure}[!htb]
              \centering
              \includegraphics[scale=0.5]{testsystem}
              \caption{Complete Test System(*Multiport interconnections not shown)}
              \label{fig:testsystem}
            \end{figure}
            
            
            The data bit width is suggested to be 80bits. This complete data is randomly generated with constraints from UVM sequencer. The UVM driver will drive the input signals to the Freyja architecture.  The data is sent as a transaction payload. 
            
        
        \begin{figure}[!htb]
            \centering
            \includegraphics[scale=0.5]{header}
            \caption{FBI Interconnect}
            \label{fig:header}
        \end{figure}
        
        \subsection{Payload and blocking transport}
        
        Each generic payload transaction has a standard set of bus attributes:
        Command
        Address
        Data
        Byte enables
        Streaming width
        Response status
        The default values are set for the unused attributes. The address is initially set in the test bench and in the Freyja architecture; each operator control block will modify the address field based on the destination operator address. The data field is set to the result of the operator process blocks.
        
        
        \subsection{Input and output}
        
         \begin{figure}[!htb]
             \centering
             \includegraphics[scale=0.5]{inputoutput}
             \caption{Input and Output of the system}
             \label{fig:inputoutput}
            \end{figure}
        
        The input file is the description of the protocol using the language defined by the EBNF grammar. The input file is parsed by the Antlr tool; the backend functions are triggered during parsing to output the Freyja architecture and the reconfigurable files. The UVM test bench will send the transaction to the Freyja architecture. The transaction is initiated from the UVM to the Freyja architecture and the final transaction is received back in the UVM. An example of instantiating 4 operator blocks as in Figure~\ref{fig:Overallarchitecture} is shown below :
        
        \begin{lstlisting}[caption={Freyja Overall architecture definition}]
        <@\textcolor{blue}{Operator}@> OPERATOR1{
        <@\textcolor{red}{sc\_name}@> : op1;
        <@\textcolor{red}{op\_type}@> : op11,op12;
        <@\textcolor{red}{errorid}@> : 01,02;
        }
        
        <@\textcolor{blue}{Operator}@> OPERATOR2{
        <@\textcolor{red}{sc\_name}@> : op2;
        <@\textcolor{red}{op\_type}@> : op21,op22,op23;
        <@\textcolor{red}{errorid}@> : 03,04,05;
        }
        
         <@\textcolor{blue}{Operator}@> OPERATOR3{
         <@\textcolor{red}{sc\_name}@> : op3;
         <@\textcolor{red}{op\_type}@> : op31;
         <@\textcolor{red}{errorid}@> : 06;
         }
        
        <@\textcolor{blue}{Operator}@> OPERATOR4{
        <@\textcolor{red}{sc\_name}@> : op4;
        <@\textcolor{red}{op\_type}@> : op41,op42;
        <@\textcolor{red}{errorid}@> :  07;
        }

        \end{lstlisting}
          
        
       
         \subsection{Blocking transport and timing annotation}
         The transaction is sent through the socket using the b\_transport method of the TLM\-2.0 blocking transport interface, which passes its transaction arguments by reference and has no return value. The b\_transport also carries the timing annotation which is not configured as the main interest as of now is to model the functionality of the target and not modeling any timing detail.
         
         
        
        
		\clearpage

        \section{Analysis}
            This chapter explains the analysis of the framework through the integration of Ethernet protocol into the Freyja architecture. Ethernet operators are integrated into the system of files generated from the Antlr tool. To show the context switching between different protocols, Xio-s CRC16 operator is also integrated. The first section analyses the process and results of Ethernet integration and section 6.2 explains the Xio-s protocol integration.
        
        
        \subsection{Ethernet}
            Ethernet Transmit and Receive operations are explained in Fig.~\ref{fig:EthTx} and Fig.~\ref{fig:EthRx}. The \textit{Datain} in the transmit is passed from the UVM test bench.The UVM sequence is generated with first byte indicating the protocol and the second byte containing the address of the operator. Once the transaction reaches the Switch wrapper,it is decoded and forwarded to the first operator as defined by the input file.\\
            
            \autoref{Ethernet} shows the complete description of Ethernet protocol. The interconnection between different Ethernet operator is explained in this section.
            
            A part of the Ethernet description is shown in code below:
            
            \begin{lstlisting}[caption={Freyja protocol Interconnection}]
                <@\textcolor{blue}{Tx\_PATH} @>{
                <@\textcolor{red}{CONNECT} @>: proc_tx <@\textcolor{red}{to} @> crc_add; 
                <@\textcolor{red}{CONNECT} @>: crc_add <@\textcolor{red}{to} @> pre_sfd_add;
                <@\textcolor{red}{CONNECT} @>: pre_sfd_add <@\textcolor{red}{to} @> cc_a;
                <@\textcolor{red}{CONNECT} @>: cc_a <@\textcolor{red}{to} @> enc;
                <@\textcolor{red}{CONNECT} @>: enc <@\textcolor{red}{to} @> scram;
                <@\textcolor{red}{CONNECT} @>: scram <@\textcolor{red}{to} @> gb_tx;
                <@\textcolor{red}{CONNECT} @>: gb_tx <@\textcolor{red}{to} @> gb_rx;
                }       
                
          \end{lstlisting}
            
          The operators required by the protocols are first instantiated by defining them in the description. The string \quotes{protocol} indicates the definition of new protocol in Freyja architecture. The new protocol definition consists of 3 segments : Fields,Tx\_path,Rx\_Path. 
          \begin{itemize}
          
          \item{The Fields section is defined to indicate the details of transaction contents in each protocol}
          \item{Tx\_Path is used to define the transmitter sequence and}
          \item{Rx\_Path is used to define the Receiver sequence}
        
         \end{itemize}
        
         The Tx\_Path and Rx\_Path are for the user to distinguish between the Transmitter and Receiver sequence for each protocol. In Freyja architecture the interconnections have no difference w.r.t Tx\_Path and Rx\_Path. The interconnect information is used to code the control block of each operator to forward the transaction to the correct destination.          
        
      
         A part of control block of CRC operator for the description of Ethernet protocol is shown below:
         
         
         \begin{lstlisting}[caption={Freyja CRC operator Control Block code segment}]
//part of fre_op_ctrl_crc.cpp block 
            
if(type == ethernet){
    if(op_type == crc_add){
        data[0] = ethernet;
        sz = sz + 2;
        data[1] = pre_sfd_add;
        gp.set_address(crc_add_2_pre_sfd_add);
    }
    else if(op_type == crc_check){
        data[0] = ethernet;
        sz = sz + 2;
        data[1] = proc;
        gp.set_address(crc_check_2_proc);
    }             
}    
         \end{lstlisting}
         
         
         In the above code the CRC operator's control block initially check for the protocol and then for the type of the operator. As explained in Fig.~\ref{fig:CRC},the CRC operator multiplex 2 operations. CRC add and CRC check operators are having the same destination operator control block. They share the common memory,hardware for CRC computation and control function. The extra logic required to perform the CRC add and CRC compare are different.\\ 
         
         The destination address of the transaction is obtained from the input file. This information is compiled in the form of constants in SystemC environment. The same information can be stored in shared or in the operator memory based on architecture requirement.\\ 
         
         The parser implemented will generate these constants which are required for the reconfiguration of hardware. The context here is the possibility to send the transaction to different operators from the same source.\\ 
         
         \begin{lstlisting}[caption={Freyja Reconfiguration constants}]
//constants for the protocol : ethernet
const unsigned char ethernet = 0;
const  int proc_2_crc_add=0;
const  int crc_add_2_pre_sfd_add=1;
const  int pre_sfd_add_2_cc_a=2;
const  int cc_a_2_enc=3;
const  int enc_2_scram=4;
const  int scram_2_gb=5;
const  int gb_2_descram=5;
const  int descram_2_dec=7;
const  int dec_2_cc_d=8;
const  int cc_d_2_pre_sfd_del=2;
const  int pre_sfd_del_2_crc_check=1;
const  int crc_check_2_proc=0;             
            \end{lstlisting}
         
         The constants are formed using simple syntax as below \\
         
         \la source operator \ra \_2\_ \la Destination operator \ra \\
         
         The constant value assigned is calculated by the parser based on the Multipass through ports of switch port to which the source and destination operators are connected.
         
         The CRC operator also contains 19 bytes of memory elements. These 19 bytes are used by both CRC32 and CRC16 Operators. Ethernet protocol uses only CRC32 and hence only crc\_add and crc\_check uses first 9 bytes of the memory elements. The parser supports the access of contiguous or individual element. After the control block informs the memory about the protocol and operator, the memory block will send the transaction to the process block which includes the constants required by the operator.   
         
        
        \subsection{Xio-s}
        
        Xio-s protocol is breifly explained in section \ref{xio}. The Xio-s protocol CRC block is integrated into the system. The control block will check for the type of protocol, prioritized according to the description in the input file. Similarly Operators are prioritized in the order they have been defined in the input file.
        Defining Xio-s after Ethernet protocol description will change the control block  code segment as shown below.\\ \\
        
        \begin{lstlisting}[caption={Freyja CRC Ctrl block with 2 protocols}]
//part of fre_op_ctrl_crc.cpp block             
if(type == ethernet){
    if(op_type == crc_add){
        ...
    }
    else if(op_type == crc_check){
        ...
    }             
}
else if(type == xios){
    if(op_type == crc_add){
        ...
    }
    else if(op_type == crc_check){
    ...
    }             
}
\end{lstlisting}
        
        As illustrated in Fig.~\ref{fig:Xiotx} and Fig.~\ref{fig:XioRx}, Xio-s protocol requires 2 interfaces to transmit the transaction from one operator to multiple operators. The transactions are sent from \textit{packet service} block to two other operators both in transmission and during receiving stage. This feature is included in the input description. The \textit{Tx\_path} and \textit{Rx\_Path} in each protocol description will allow the user to define multiple destination operators for the same source operator. The code below depicts a scenario of Xio-s protocol assuming \textbf{ps}, \textbf{crc\_add\_16} and \textbf{cc\_a\_xio} are the operators described in the input file.  
        
        \begin{lstlisting}[caption={Freyja One source to multiple destination interconnection}]
        <@\textcolor{blue}{Tx\_PATH} @>{
        <@\textcolor{red}{CONNECT} @>: ps <@\textcolor{red}{to} @> crc_add_16; 
        <@\textcolor{red}{CONNECT} @>: ps <@\textcolor{red}{to} @> cc_a_xio;
        }       
        
        \end{lstlisting}
        
        Similar logic applies to the receiver section which can be parsed to receive the transaction from different source operators. Assuming \textbf{fs1},\textbf{fs2} and \textbf{aligner} are Xio-s protocol operators, the below code indicate the way to receive transaction from multiple sources.
        
        \begin{lstlisting}[caption={Freyja multiple source to one destination interconnection}]
        <@\textcolor{blue}{Rx\_PATH} @>{
        <@\textcolor{red}{CONNECT} @>: fs1 <@\textcolor{red}{to} @> aligner; 
        <@\textcolor{red}{CONNECT} @>: fs2 <@\textcolor{red}{to} @> aligner;
        }
        \end{lstlisting}
        
        
        But the Freyja Operator as explained in section \ref{operator} consists of only one interface. This need the change in architecture of operator units and a single interface will not be possible to model the Xio-s protocol. The operators can be customized by defining more strings in the operator instantiation stage. Once the architecture is modeled, the parsed input description can be used to output the architecture to match the interface requirement.     
        
        
        context switching at process block 
  
        \clearpage

		\section{Conclusion and Future work}
        This chapter concludes the thesis by describing the learning outcomes of reconfigurable architectures used for protocol processing and the framework design by grammar based language application. It also describes the limitations encountered during the thesis work and further section describes the future work specific to the thesis work and in general to the research topic. 
        
        
        \subsection{Reconfigurable architecture} \label{rconf}
           
           Ericsson AB investigated Switch and Mesh based network topology for efficient protocol processing. Based on performance,cost,scalability and other internal factors switch based network topology named as Freyja is considered for further implementation and research. The reconfigurable hardware implemented using systemC consisted of a central switch with all the operators connected to it as explained in section \ref{freyja}.\\       
           
           The design of a new architecture require manually setting up simulations,estimation of resources and synthesizing the hardware which consists of system,logic and physical synthesis. This is a time consuming process and decreases the productivity of the research. Research project called TACO(Tools for Application-specific Hardware/Software Codesign) at university of Turku, explains the functions,features and capabilities required by such a tool \cite{taco}. One such requirement is importing architecture details in the tool from systemC top level files. The same approach is carried in Freyja architecture by abstracting the systemC details into the high level description.\\ 
           
           The main objective of this work is to show the complete process of mapping from high level description to the system level implementation. The features mapped consisted of different operator instantiation,interconnections,memory,error handling and routing to multiple destinations from each operators for different protocols. In general protocol processors are more complex including features like Flow control,FIFOs,arbitration mechanism,latency of each computation,dead lock avoidance etc.\\    
           
           The mapping of such finer details in the high level description will be straight forward with the approach presented in this work.
           For example the FIFOs can be instantiated similar to the Operator instantiation by extending the grammar. The FIFO block can be further configured with the variable depth of the buffer and signaling the overloading because of back pressure. How these details are represented in high level description depends on the architecture implementation. Another example of extension is to extend the grammar to hold the latency of each operator.
           
           The same framework can be used at different levels of synthesis to output the required files for the architecture. This reduces the time to reconfigure and setup the environment. For all these to accomplish, the reconfigurable architecture should be defined. The framework can be adapted based on the architecture. The approach in this work shows the concept of mapping few core features which are easy to extend for more refined details.\\
           
           Apart from abstracting high level architecture details, the core functions of each operator can also be represented using high level description. More research in academia and industry have already proved the concept. These tools input from Algorithms to Register Transfer level (ALU,Reg,Mux). This transformation is called as High level synthesis \cite{hls} \cite{5209958}.\\
           
           
        \subsection{Protocol sharing} 
         
         As illustrated in section \ref{protocol} the protocols share common functions. The features that can be shared are discussed at system level based on algorithms. The gain of sharing and reducing the hardware cost comes with the need of reconfiguration and back pressure in the system. The buffer length required to handle this and further details can be abstracted to the higher level to produce the reconfiguration content for the architecture. Automating the calculation of these resource utilization through simulation and importing the result to configure the hardware will reduce the architecture design time. \\
         
         The implemented work shows the concept of mapping one resource to different protocols. Sharing requires arbitration algorithms to decide who can access the operator at any instant of time. It can be based on priority. However mathematical tools like Matlab can be used to implement the equations and calculate the resource usage. More utilized resources like CRC computation can be replicated for avoiding the back pressure. TACO project \cite{taco} provides a similar research conclusion for the protocol processor which exploits the resource sharing at logic levels. The tool identifies the common hardware blocks and creates multiple cores of them to meet the constraints. Similar approach can be extended with Freyja architecture for frequently used operators.\\
         
         
         Some bottlenecks would be the memory interface and token access from higher layers. The system needs to be configured with different feasible combinations for higher throughput. In future,these details can be abstracted to high level description for configure the overall system.  
        
        \subsection{Language framework}
        
        Programmers are building domain-specific languages, configuration file formats, network protocols and numerous data file formats as well as traditional programming language compilers and interpreters. The development of such systems can be made faster by using the language building tools.\\
        
        Programmers tend to avoid using language tools, resorting to adhoc methods, partly because of the raw and low level interface to these tools \cite{Bovet:2008:AAG:1410270.1410275}. Using grammar based approach to build parsers will offer a more natural, high fidelity, robust and maintainable means of encoding a language-related problem. Most grammar development is done today with a simple text editor. The ANTLR4 parser generator \cite{Parr:2007:DAR:1209320} attempts to make grammars more accessible to the programmer by generating recursive descent parsers that are very similar to what programmer would build by hand.\\
        
        
        Antlr4 supports rapid grammar developemnt by using ANTLR's built in interpreter, thus, providing immediate feedback during development \cite{Daly:2006:PES:1142473.1142568}. The parse tree associated with matching input (as in Fig.~\ref{fig:parsetree}), helps in debugging for error in grammar definition. If the input sequence is not in the language recognized by specified start rule, Antlr4 inserts an error node into the parse tree to indicate where the problem occurred. 
        
       All the above features of Antlr4 tool helps to build the language application in a more structured way. Providing the framework in multiple languages makes the programmer comfortable to build with their skilled language. The most encountered problems are resolved with the community support and the book written from the author Terrence Parr \cite{Parr:2007:DAR:1209320}.
        
        
        \subsection{Limitations}
         
         The thesis started with the focus of developing the complete framework and to show the concept of using grammar based language application in hardware/software co design. The reconfigurable architecture modeled in systemC abstracted more hardware details. 
         Though language is developed to include all future requirements, the implementations in the backend has to be extended for the new features of the hardware. Even though 3 protocols and their functions are discussed, it is not targeted to integrate all the protocols. As stated in section \ref{rconf} the high level description is targeted with respect to current Freyja architecture. The Antlr4 tool supports java language to output the framework and support for other languages are yet to be released.
         
         \subsection{Future work}
        
          Freyja architecture is still under implementation and in future, the complete details of the architecture can be abstracted into high level description by extending the grammar. Features like multiple core instantiations and transaction from different sources to same destination (required for Xio-s protocol) are possible to represent but still requires the backend implementations to modify according to the interconnection defined in future. Once the reconfigurable file format required by RTL hardware implementations are defined, the same framework can output such files to speedup the design process. As explained in section \ref{reconf} the granularity of Freyja architecture is at algorithmic level. Common hardware blocks at logic levels and exploiting the reconfigurability for freyja architecture can be considered further and then the grammar can be extended similar to TACO protocol processor \cite{taco}. The header as explained in Fig.~\ref{fig:header}, can be described in the high level description which provides control in manipulating the length of each field.\\
          
          The integration of Xio-s and CPRI protocols into the framework is straight forward. The process block i.e core functions of each operator needs to be modified to integrate these protocols into the system. Ethernet integration is set as an example. The grammar supports definition of multiple protocols in the language. The implementation of protocol functions doesn't require any modifications in the grammar. \\
          
          Antlr4 is made to output the framework in Java language and the tool (in future!) will support other languages like c,c++. Based on the project requirement the language can be selected. Java has good commands for File IO operations and handling the objects. Major backend implementation deals with storing the parsed data in the form of Hashmap and Linkedlist. These facts can be considered when building similar concept for other reconfigurable architectures. \\ 
        
         
          In general, the framework can be extended for all levels of synthesis while designing the hardware. The development environment will be heterogeneous at different levels and a common framework for producing the top level configurable files will reduce the errors. Once the architecture is specified, the tool can be made to generate SystemC model for simulation, a Matlab model for estimation of resources and VHDL model for synthesis of the architecture. The resource estimation can also be integrated within the tool by developing an interpreter using the parsed input. 
         
             
        
		\clearpage

	\begin{filecontents*}{references.bib}


		@INPROCEEDINGS{5335678, 
			author={Szczesny, D. and Showk, A. and Hessel, S. and Bilgic, A. and Hildebrand, U. and Frascolla, V.}, 
			booktitle={System-on-Chip, 2009. SOC 2009. International Symposium on}, 
			title={Performance analysis of LTE protocol processing on an ARM based mobile platform}, 
			year={2009}, 
			month={Oct}, 
			pages={056-063}, 
			keywords={hardware-software codesign;mobile communication;mobile handsets;virtual prototyping;ARM based mobile platform;LTE protocol processing;long term evolution layer;robust header compression;Acceleration;Computational modeling;Hardware;Long Term Evolution;Mobile computing;Mobile handsets;Performance analysis;Physical layer;Protocols;Virtual prototyping}, 
			doi={10.1109/SOCC.2009.5335678},}

			@INPROCEEDINGS{558379, 
				author={Abnous, A. and Rabaey, J.}, 
				booktitle={VLSI Signal Processing, IX, 1996., [Workshop on]}, 
				title={Ultra-low-power domain-specific multimedia processors}, 
				year={1996}, 
				month={Oct}, 
				pages={461-470}, 
				keywords={computer architecture;computer networks;digital signal processing chips;integrated circuit design;land mobile radio;mobile radio;multimedia communication;portable computers;radio equipment;communication capabilities;hybrid architecture template;multimedia services;portable communication devices;portable computing;programmable devices;signal processing applications;ultra-low-power domain-specific multimedia processors;Computer aided instruction;Computer architecture;Decoding;Digital signal processing;Energy efficiency;Kernel;Multimedia computing;Portable computers;Power engineering computing;Signal processing algorithms}, 
				doi={10.1109/VLSISP.1996.558379},}

				@INPROCEEDINGS{1106752, 
					author={Keutzer, K. and Malik, S. and Newton, A.R.}, 
					booktitle={Computer Design: VLSI in Computers and Processors, 2002. Proceedings. 2002 IEEE International Conference on}, 
					title={From ASIC to ASIP: the next design discontinuity}, 
					year={2002}, 
					month={}, 
					pages={84-90}, 
					keywords={application specific integrated circuits;logic design;programmable circuits;ASIC;ASIP;Application Specific Instruction Set Processors;Application Specific Integrated Circuits;application implementation philosophy;programmable platforms;Application software;Application specific integrated circuits;Application specific processors;Computational geometry;Costs;Design methodology;Hardware;Manufacturing;Productivity;Time to market}, 
					doi={10.1109/ICCD.2002.1106752}, 
					ISSN={1063-6404},}

					@INPROCEEDINGS{6868627, 
						author={Badawi, M. and Hemani, A. and Zhonghai Lu}, 
						booktitle={Application-specific Systems, Architectures and Processors (ASAP), 2014 IEEE 25th International Conference on}, 
						title={Customizable coarse-grained energy-efficient reconfigurable packet processing architecture}, 
						year={2014}, 
						month={June}, 
						pages={30-35}, 
						keywords={application specific integrated circuits;multiprocessing systems;reconfigurable architectures;agile reconfigurability;custom ASIC implementation;customizable coarse grained energy efficient reconfigurable packet processing architecture;hardwired ASIC implementation;programmable protocol processor;real-life Voice-Over IP traffic;reconfigurable multicore packet processing architecture;retaining flexibility;time critical adaptability;Application specific integrated circuits;Delays;IP networks;Program processors;Protocols;Registers;Time factors}, 
						doi={10.1109/ASAP.2014.6868627},}

						@ARTICLE{1114865, 
							author={Estrin, G.}, 
							journal={Annals of the History of Computing, IEEE}, 
							title={Reconfigurable computer origins: the UCLA fixed-plus-variable (F+V) structure computer}, 
							year={2002}, 
							month={Oct}, 
							volume={24}, 
							number={4}, 
							pages={3-9}, 
							keywords={reconfigurable architectures;UCLA fixed-plus-variable structure computer;University of California at Los Angeles;models;reconfigurable computer architectures;reconfigurable systems analysis;reconfigurable systems design;tools;Circuits;Computer architecture;Contracts;Hardware;High performance computing;Laboratories;Mathematics;Microprocessors;System analysis and design;Telephony}, 
							doi={10.1109/MAHC.2002.1114865}, 
							ISSN={1058-6180},}

							@misc{page1985re,
								title={Re-programmable PLA},
								author={Page, D.W. and Peterson, L.V.R.},
								url={http://www.google.com/patents/US4508977},
								year={1985},
								month=apr # "~2",
								publisher={Google Patents},
								note={US Patent 4,508,977}
							}

                        @article{JACST518,
	                    author = {Abida Waza and Roohie Naaz Mir and Hakim Najeeb-ud-din},
	                    title = {Reconfigurable Architectures},
	                    journal = {Journal of Advanced Computer Science \& Technology},
                    	volume = {1},
	                    number = {4},
                    	year = {2012},
	                    keywords = {},
	                    abstract = {In the area of computer architecture, designers are faced with the trade-of between flexibility and performance. The architectural choices span a wide spectrum, with general-purpose processors and application specific integrated circuits (ASICs) at opposite ends. General-purpose processors are not optimized to specific applications; they are flexible due to their versatile instruction sets that allow the implementation of every computable task. ASICs are dedicated hardware devices that can achieve higher performance, require less silicon area, and are less power-consuming than instruction-level programmable processors. However, they lack in flexibility. Reconfigurable computer architectures promise to overcome this traditional trade-off and achieve both, the high performance of ASICs and the flexibility of general-purpose processors.},
	                    issn = {2227-4332},
	                    url = {http://www.sciencepubco.com/index.php/JACST/article/view/518},
	                    pages = {337--346}

                    	@INPROCEEDINGS{5351593, 
	                	author={Shami, M.A. and Hemani, A.}, 
	                	booktitle={ASIC, 2009. ASICON '09. IEEE 8th International Conference on}, 
		                title={Partially reconfigurable interconnection network for dynamically reprogrammable resource array}, 
		                year={2009}, 
		                month={Oct}, 
	                	pages={122-125}, 
	                	keywords={multiprocessor interconnection networks;reconfigurable architectures;binary encoding;dynamically reprogrammable resource array;innovative regular nonblocking interconnection network;low latency interconnection network;partially reconfigurable interconnection network;point-to-multipoint interconnection network;point-to-point interconnection network;sliding window connectivity;Delay;Energy efficiency;Fabrics;Multiplexing;Multiprocessor interconnection networks;Nearest neighbor searches;Parallel processing;Reconfigurable architectures;Reconfigurable logic;Signal processing algorithms;CGRA;Dynamically Reconfigurable;Interconnects;Partially Reconfigurable}, 
		                doi={10.1109/ASICON.2009.5351593},}
                    
                    
                         @comment{ Anne Håkansson, Portal of Research Methods and Methodologies for 
                             Research Projects and Degree Projects. WORLDCOMP'13 - The 2013 
                             World Congress in Computer Science, Computer Engineering, and 
                             Applied Computing, 22-25 July, 2013 Las Vegas, Nevada; USA }
                            @book{2013portal,
                                author = "Anne Håkansson",
                                title = "Portal of Research Methods and Methodologies for Research Projects and Degree Projects",
                                publisher = "WORLDCOMP'13 - The 2013 World Congress in Computer Science, Computer Engineering, and Applied Computing",
                                pages = "22--25",
                                year = 2013
                            }
                            
                           @ARTICLE{1617814, 
                               journal={IEEE Std 1666-2005}, 
                               title={IEEE Standard System C Language Reference Manual}, 
                               year={2006}, 
                               month={}, 
                               pages={0\_1-423}, 
                               doi={10.1109/IEEESTD.2006.99475},}
                            
                           @ARTICLE{4066263, 
                               author={Peterson, W.W. and Brown, D.T.}, 
                               journal={Proceedings of the IRE}, 
                               title={Cyclic Codes for Error Detection}, 
                               year={1961}, 
                               month={Jan}, 
                               volume={49}, 
                               number={1}, 
                               pages={228-235}, 
                               keywords={Binary codes;Data communication;Decoding;Encoding;Error correction codes;Feedback;Fires;Information theory;Mathematics;Polynomials}, 
                               doi={10.1109/JRPROC.1961.287814}, 
                               ISSN={0096-8390},}
                            
                            
                           @MISC{antlr4,
                               author = {Terence Parr, Sam Harwell and Kathleen Fisher},
                               title = {Adaptive LL(*) Parsing: The Power of Dynamic Analysis},
                               month = March,
                               year = {2014},
                               howpublished = "\url{http://www.antlr.org/papers/allstar-techreport.pdf}",
                               note = "[Online; accessed 1-March-2015]",
                               url = {http://www.antlr.org/papers/allstar-techreport.pdf}}
                            
                            
                          @INPROCEEDINGS{4291932, 
                              author={Genest, G. and Chamberlain, R. and Bruce, R.}, 
                              booktitle={Adaptive Hardware and Systems, 2007. AHS 2007. Second NASA/ESA Conference on}, 
                              title={Programming an FPGA-based Super Computer Using a C-to-VHDL Compiler: DIME-C}, 
                              year={2007}, 
                              month={Aug}, 
                              pages={280-286}, 
                              keywords={field programmable gate arrays;hardware description languages;logic CAD;parallel machines;program compilers;programming;64-node FPGA-based supercomputer programming;C-to-VHDL compiler;Nallatech DIME-C compiler;design methodology;ANSI standards;Algorithm design and analysis;Circuits;Electronic design automation and methodology;Field programmable gate arrays;Hardware design languages;High level languages;Logic;Pipelines;Program processors}, 
                              doi={10.1109/AHS.2007.89},}
                            
                            
                            
                          @ARTICLE{998629, 
                              author={Bergamaschi, R.}, 
                              journal={Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on}, 
                              title={Bridging the domains of high-level and logic synthesis}, 
                              year={2002}, 
                              month={May}, 
                              volume={21}, 
                              number={5}, 
                              pages={582-596}, 
                              keywords={data flow graphs;high level synthesis;logic CAD;minimisation of switching nets;processor scheduling;RTL/gate-level network;algorithmic decision;allocation;control/data flow graphs;hardware cost estimation;hardware implementation;high-level synthesis;interleaving;internal model;logic synthesis;logic transformations;register-transfer-level model;scheduling;Costs;Flow graphs;Hardware;High level synthesis;Logic design;Logic gates;Network synthesis;Processor scheduling;Resource management;Scheduling algorithm}, 
                              doi={10.1109/43.998629}, 
                              ISSN={0278-0070},}
                            
                            
                            @INPROCEEDINGS{5469564, 
                                author={Mena, J.G. and Deken, R. and Coker, J.E. and Johnstone, M.S. and Ramirez, S.R. and Frey, P.}, 
                                booktitle={VLSI Test Symposium (VTS), 2010 28th}, 
                                title={High level synthesis of a Front End filter and DSP engine for analog to digital conversion x2013; a case study}, 
                                year={2010}, 
                                month={April}, 
                                pages={252-252}, 
                                keywords={analogue-digital conversion;digital signal processing chips;electronic engineering computing;high level synthesis;object-oriented programming;SystemC;analog to digital conversion;front end DSP engine;front end filter;high level synthesis;object oriented programming;sine cubed decimator;Analog-digital conversion;Digital filters;Digital signal processing;Engines;High level synthesis;Microarchitecture;Object oriented modeling;Productivity;Silicon compiler;Timing}, 
                                doi={10.1109/VTS.2010.5469564}, 
                                ISSN={1093-0167},}
                            
                            @INPROCEEDINGS{5681536, 
                                author={Kaneta, Y. and Yoshizawa, S. and Minato, S. and Arimura, H. and Miyanaga, Y.}, 
                                booktitle={Field-Programmable Technology (FPT), 2010 International Conference on}, 
                                title={Dynamic reconfigurable bit-parallel architecture for large-scale regular expression matching}, 
                                year={2010}, 
                                month={Dec}, 
                                pages={21-28}, 
                                keywords={deterministic automata;field programmable gate arrays;finite automata;parallel architectures;random-access storage;reconfigurable architectures;string matching;DFA-based dynamic reconfigurable architectures;FPGA-based architecture;bit-masks;bit-parallel NFA-simulation;bit-parallel pattern matching approach;block RAM;dynamic BP-NFA;dynamic reconfigurable bit-parallel NFA architecture;dynamic reconfigurable bit-parallel architecture;large-scale regular expression matching;nondeterministic finite automata;string matching;Decoding;Field programmable gate arrays;Hardware;Indexes;Pattern matching;Random access memory;Registers}, 
                                doi={10.1109/FPT.2010.5681536},}
                            
                            @INPROCEEDINGS{1395538, 
                                author={Panainte, E.M. and Bertels, K. and Vassiliadis, S.}, 
                                booktitle={Design, Automation and Test in Europe, 2005. Proceedings}, 
                                title={Instruction scheduling for dynamic hardware configurations [M-JPEG encoder case study]}, 
                                year={2005}, 
                                month={March}, 
                                pages={100-105 Vol. 1}, 
                                keywords={directed graphs;discrete cosine transforms;field programmable gate arrays;processor scheduling;quantisation (signal);reconfigurable architectures;variable length codes;video coding;DCT;FCCM;FPGA area placement conflicts;FPGA reconfiguration latency;M-JPEG encoder speedup;compiler analyses techniques;control flow graph;directed graph;dynamic hardware configuration;executed hardware reconfiguration instructions minimization;feedback-directed techniques;field-programmable custom computing machines;instruction scheduling algorithm;operation hardware execution;operation software execution;quantization;variable length coding;Algorithm design and analysis;Application software;Delay;Dynamic scheduling;Field programmable gate arrays;Hardware;Scheduling algorithm;Software algorithms;Switches;Testing}, 
                                doi={10.1109/DATE.2005.184}, 
                                ISSN={1530-1591},}
                           
                                               
                        
                                                      
                            
                          @MISC{ericsson,
                              author = {},
                              title = {Ericsson AB},
                              month = July,
                              year = {2015},
                              howpublished = "\url{http://www.ericsson.com/}",
                              note = "[Online; accessed 1-March-2015]",
                              url = {http://www.ericsson.com/}}  
                            
                            
                            
                        @MISC{iethernet,
                            author = {},
                            title = {IEEE Standard for Ethernet},
                            month = July,
                            year = {2012},
                            howpublished = "\url{https://standards.ieee.org/about/get/802/802.3.html}",
                            note = "[Online; accessed 1-Feb-2015]",
                            url = {https://standards.ieee.org/about/get/802/802.3.html}}    
                          
                        @MISC{cpri,
                              author = {},
                              title = {CPRI specification overview},
                              month = July,
                              year = {2014},
                              howpublished = "\url{http://www.cpri.info/spec.html}",
                              note = "[Online; accessed 1-Feb-2015]",
                              url = {http://www.cpri.info/spec.html}}  
                          
                        @incollection{book,
                            year={2011},
                            isbn={978-1-4419-8585-9},
                            booktitle={The Simple Art of SoC Design},
                            doi={10.1007/978-1-4419-8586-6_12},
                            title={The Future of Design},
                            url={http://dx.doi.org/10.1007/978-1-4419-8586-6_12},
                            publisher={Springer New York},
                            author={Keating, Michael},
                            pages={171-180},
                            language={English}
                          }  
                          
                         
                          @MISC{tlm,
                              author = {},
                              title = {TLM 2.0 Transaction Level Modeling Library and whitepaper},
                              month = July,
                              year = {2009},
                              howpublished = "\url{http://accellera.org/downloads/standards/systemc}",
                              note = "[Online; accessed 1-Feb-2015]",
                              url = {http://accellera.org/downloads/standards/systemc}}  
                         
                           @MISC{uvm,
                               author = {},
                               title = {Standard Universal Verification Methodology Class Reference},
                               month = July,
                               year = {2014},
                               howpublished = "\url{ http://accellera.org/downloads/standards/uvm}",
                               note = "[Online; accessed 1-Feb-2015]",
                               url = { http://accellera.org/downloads/standards/uvm}}   
                            
                            @MISC{sematech,
                                author = {Semiconductor Industry Association},
                                title = {The International Technology Roadmap for Semiconductors SEMATECH: Austin, 2009},
                                month = July,
                                year = {2009}}
                               
                               
                               
                            @InProceedings{taco,
                                author = {Seppo Virtanen and Tomas Lundstr¨om and Johan Lilius},
                                title = {A Design Tool for the TACO Protocol
                                    Processor Development Framework},
                                booktitle = {n Proceedings of the 18 IEEE NorChip conference, 6-7 November 2000, Turku, Finland },
                                month =,
                                year = ,
                                publisher = {},
                                editor = {},
                                pages = {},}
                            
                         @article{Bovet:2008:AAG:1410270.1410275,
                             author = {Bovet, Jean and Parr, Terence},
                             title = {ANTLRWorks: An ANTLR Grammar Development Environment},
                             journal = {Softw. Pract. Exper.},
                             issue_date = {October 2008},
                             volume = {38},
                             number = {12},
                             month = oct,
                             year = {2008},
                             issn = {0038-0644},
                             pages = {1305--1332},
                             numpages = {28},
                             url = {http://dx.doi.org/10.1002/spe.v38:12},
                             doi = {10.1002/spe.v38:12},
                             acmid = {1410275},
                             publisher = {John Wiley \& Sons, Inc.},
                             address = {New York, NY, USA},
                             keywords = {GUI, debugger, grammar development, parser, rapid prototyping},
                            } 
                         
                         @book{Parr:2007:DAR:1209320,
                             author = {Parr, Terence},
                             title = {The Definitive ANTLR Reference: Building Domain-Specific Languages},
                             year = {2007},
                             isbn = {0978739256},
                             publisher = {Pragmatic Bookshelf},
                         }   
                         
                         @inproceedings{Daly:2006:PES:1142473.1142568,
                             author = {Daly, Mark and Mandelbaum, Yitzhak and Walker, David and Fern\'{a}ndez, Mary and Fisher, Kathleen and Gruber, Robert and Zheng, Xuan},
                             title = {PADS: An End-to-end System for Processing Ad Hoc Data},
                             booktitle = {Proceedings of the 2006 ACM SIGMOD International Conference on Management of Data},
                             series = {SIGMOD '06},
                             year = {2006},
                             isbn = {1-59593-434-0},
                             location = {Chicago, IL, USA},
                             pages = {727--729},
                             numpages = {3},
                             url = {http://doi.acm.org/10.1145/1142473.1142568},
                             doi = {10.1145/1142473.1142568},
                             acmid = {1142568},
                             publisher = {ACM},
                             address = {New York, NY, USA},
                            } 
                         
                          @book{hls,
                              author = {Philippe Coussy, Adam Morawiec},
                              title = {High-Level Synthesis: From Algorithm to Digital Circuit},
                              year = {2008},
                              isbn = {978-1-4020-8588-8},
                              publisher = {Springer Netherlands},
                            } 
                         
                         @ARTICLE{5209958, 
                             author={Coussy, P. and Gajski, D.D. and Meredith, M. and Takach, A.}, 
                             journal={Design Test of Computers, IEEE}, 
                             title={An Introduction to High-Level Synthesis}, 
                             year={2009}, 
                             month={July}, 
                             volume={26}, 
                             number={4}, 
                             pages={8-17}, 
                             keywords={high level synthesis;HLS techniques;abstraction level design;high-level synthesis;optimized RTL hardware;Application software;Assembly;Circuit simulation;Circuit synthesis;Computer architecture;Design methodology;Design optimization;Hardware design languages;High level synthesis;Space exploration;RTL abstraction;architectures;custom processors;design and test;hardware synthesis and verification;high-level synthesis}, 
                             doi={10.1109/MDT.2009.69}, 
                             ISSN={0740-7475},}
                         
                                                  
}


\end{filecontents*}
\bibliographystyle{ieeetr}
\bibliography{references}
\addcontentsline{toc}{section}{References}
\cleardoublepage

\phantomsection
\appendix
\appendixpage
\addcontentsline{toc}{section}{\appendixname}
%\cleardoublepage

\section{Ethernet Protocol Description}
\label{Ethernet}
\begin{lstlisting}

<@\textcolor{blue}{FunctionUnits}@> FREYJA:

<@\textcolor{blue}{Operator}@> PROCESSOR{
<@\textcolor{red}{sc\_name}@> : proc;
<@\textcolor{red}{op\_type}@> : proc_tx,proc_rx;
<@\textcolor{red}{errorid}@> : 01,13;
}

<@\textcolor{blue}{Operator}@> CHECKSUM{
<@\textcolor{red}{sc\_name}@> : crc;
<@\textcolor{red}{op\_type}@> : crc_add,crc_check;
<@\textcolor{red}{op\_mem}@>  : 0x01,0x04,0xc1,0x1d,0xb7,0x20,0x00,0x04,0x03,
0x04,0x00,0x00,0x01,0x59,0x53,0x10,0x03,0x02,0x04;
<@\textcolor{red}{errorid}@> : 02,03;
}

<@\textcolor{blue}{Operator}@> PRE_SFD{
<@\textcolor{red}{sc\_name}@> : pre_sfd_add;
<@\textcolor{red}{op\_type}@> : pre_sfd_add,pre_sfd_del;
<@\textcolor{red}{errorid}@> : 04,05;
}

<@\textcolor{blue}{Operator}@> CORRECTING_CODES_ADD{
<@\textcolor{red}{sc\_name}@> : cc_a;
<@\textcolor{red}{op\_type}@> : cc_a;
<@\textcolor{red}{errorid}@> : 06;
}

<@\textcolor{blue}{Operator}@> ENCODER{
<@\textcolor{red}{sc\_name}@> : enc_64_66;
<@\textcolor{red}{op\_type}@> : enc;
<@\textcolor{red}{errorid}@> : 07;
}

<@\textcolor{blue}{Operator}@> SCRAMBLER{
<@\textcolor{red}{sc\_name}@> : scram;
<@\textcolor{red}{op\_type}@> : scram,descram;
<@\textcolor{red}{op\_mem}@>  : 0x01,0x00,0x00,0x00,0x80,0x00,0x00,0x04; 
<@\textcolor{red}{errorid}@> : 08;
}

<@\textcolor{blue}{Operator}@> GEARBOX_TX{
<@\textcolor{red}{sc\_name}@> : gb_tx;
<@\textcolor{red}{op\_type}@> : gb_tx;
<@\textcolor{red}{errorid}@> : 09;
}

<@\textcolor{blue}{Operator}@> GEARBOX_RX{
<@\textcolor{red}{sc\_name}@> : gb_rx;
<@\textcolor{red}{op\_type}@> : gb_rx;     
<@\textcolor{red}{errorid}@> : 13;
}

<@\textcolor{blue}{Operator}@> FRAMESYNC{
<@\textcolor{red}{sc\_name}@> : fs;
<@\textcolor{red}{op\_type}@> : fs;
<@\textcolor{red}{errorid}@> : 10;
}

<@\textcolor{blue}{Operator}@> DECODER{
<@\textcolor{red}{sc\_name}@> : dec_66_64;
<@\textcolor{red}{op\_type}@> : decdr;
<@\textcolor{red}{errorid}@> : 11;
}

<@\textcolor{blue}{Operator}@> CORRECTING_CODES_DEL{
<@\textcolor{red}{sc\_name}@> : cc_d;
<@\textcolor{red}{op\_type}@> : cc_d;
<@\textcolor{red}{errorid}@> : 12;
}


<@\textcolor{blue}{protocol}@>  ETHERNET 
<@\textcolor{cyan}{fields}@> : DA[06]
SA[06]
VLAN:0x8100
VLAN[02]
Len[02]
PL[20]


<@\textcolor{blue}{memory} @>{
<@\textcolor{red}{crc\_add} @>   :00 <@\textcolor{red}{to} @> 08;
<@\textcolor{red}{crc\_check} @> :00 <@\textcolor{red}{to} @> 07,09;
<@\textcolor{red}{scram} @>     :00 <@\textcolor{red}{to} @> 07: 
<@\textcolor{red}{descram} @>   :00 <@\textcolor{red}{to} @> 07;
} 


<@\textcolor{blue}{Tx\_PATH} @>{
<@\textcolor{red}{CONNECT} @>: proc_tx <@\textcolor{red}{to} @> crc_add; 
<@\textcolor{red}{CONNECT} @>: crc_add <@\textcolor{red}{to} @> pre_sfd_add;
<@\textcolor{red}{CONNECT} @>: pre_sfd_add <@\textcolor{red}{to} @> cc_a;
<@\textcolor{red}{CONNECT} @>: cc_a <@\textcolor{red}{to} @> enc;
<@\textcolor{red}{CONNECT} @>: enc <@\textcolor{red}{to} @> scram;
<@\textcolor{red}{CONNECT} @>: scram <@\textcolor{red}{to} @> gb_tx;
<@\textcolor{red}{CONNECT} @>: gb_tx <@\textcolor{red}{to} @> gb_rx;
}       


<@\textcolor{blue}{RX\_PATH} @>{
<@\textcolor{red}{CONNECT} @>: gb_rx <@\textcolor{red}{to} @> descram;
<@\textcolor{red}{CONNECT} @>: descram <@\textcolor{red}{to} @> decdr;
<@\textcolor{red}{CONNECT} @>: decdr <@\textcolor{red}{to} @> cc_d;
<@\textcolor{red}{CONNECT} @>: cc_d <@\textcolor{red}{to} @> pre_sfd_del;
<@\textcolor{red}{CONNECT} @>: pre_sfd_del <@\textcolor{red}{to} @> crc_check;
<@\textcolor{red}{CONNECT} @>: crc_check <@\textcolor{red}{to} @> proc_rx;
}

\end{lstlisting}



\clearpage

\section{Language Recognition terms}
\label{language}

\subsubsection*{Language}  A Language is a set of valid sentences which are  composed of phrases,sub-phrases and so on. 

\subsubsection*{Grammar}  A Grammar formally defines the syntax rules of a language.

\subsubsection*{Syntax tree or Parse tree}  This is a tree structure representation of a sentence.The leaves of the tree are symbols or tokens of the sentence

\subsubsection*{Token}  A token is a symbol in a language like Identifier, keyword or an operator symbol.

\subsubsection*{Lexer}  It performs lexical analysis by conversting input character streams into Tokens.

\subsubsection*{Parser}  A Parser checks the sentence structure against the rules of a grammar.

\subsubsection*{Top down parser} It is a type of parsing strategy where one first looks at the highest level OF Parse tree (root) and works down the parse tree by reaching the leaf nodes.

\subsubsection*{Bottom up parser} In this parsing strategy the input text is processed from the lowest level to highest level (root).


\subsubsection*{Recursive Descent Parser} It is a kind of top down parser built from a set of mutually recursive procedures where each such procedure usually implements one of the productions of the grammar.

\subsubsection*{LookAhead parser}  It defines the number of tokens accessible to the parser in making decisions at each point. 


\subsubsection*{Left recursion} 

\subsubsection*{context free grammar}

\subsubsection*{Regular grammar}

\end{document}
